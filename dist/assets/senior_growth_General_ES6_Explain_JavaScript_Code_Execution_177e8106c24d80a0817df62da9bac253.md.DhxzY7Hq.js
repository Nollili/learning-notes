import{_ as s,c as t,o as a,af as i}from"./chunks/framework.C3eVOF8n.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/General_ES6/Explain_JavaScript_Code_Execution_177e8106c24d80a0817df62da9bac253.md","filePath":"senior_growth/General_ES6/Explain_JavaScript_Code_Execution_177e8106c24d80a0817df62da9bac253.md"}'),n={name:"senior_growth/General_ES6/Explain_JavaScript_Code_Execution_177e8106c24d80a0817df62da9bac253.md"};function o(l,e,r,h,c,p){return a(),t("div",null,[...e[0]||(e[0]=[i(`<h3 id="explain-javascript-code-execution" tabindex="-1">Explain JavaScript Code Execution <a class="header-anchor" href="#explain-javascript-code-execution" aria-label="Permalink to “Explain JavaScript Code Execution”">​</a></h3><p>JavaScript code execution involves several steps that are managed by the <strong>JavaScript Engine</strong>, which is responsible for interpreting and running the code. The process involves various components like <strong>Call Stack</strong>, <strong>Heap</strong>, <strong>Event Loop</strong>, <strong>Execution Context</strong>, and <strong>Memory Management</strong>.</p><p>Let’s break down the process to understand how JavaScript executes code from start to finish.</p><hr><h3 id="_1-javascript-execution-context" tabindex="-1"><strong>1. JavaScript Execution Context</strong> <a class="header-anchor" href="#_1-javascript-execution-context" aria-label="Permalink to “1. JavaScript Execution Context”">​</a></h3><p><a href="https://www.youtube.com/watch?v=zdGfo6I1yrA&amp;ab_channel=LydiaHallie" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=zdGfo6I1yrA&amp;ab_channel=LydiaHallie</a></p><p>Before diving into the flow, it’s important to understand <strong>Execution Context</strong>. Every time a function is invoked or code is executed in JavaScript, an <strong>execution context</strong> is created. It contains information about the environment in which the code is running, including variable scope, function declarations, and the <code>this</code> keyword.</p><p>An <strong>execution context</strong> has three main components:</p><ul><li><strong>Variable Object (VO)</strong>: Holds variables and function declarations.</li><li><strong>Scope Chain</strong>: Keeps track of the current variable scope, which allows JavaScript to access variables in parent scopes.</li><li><strong><code>this</code> Keyword</strong>: Refers to the current execution context, i.e., the object that is executing the current piece of code.</li></ul><p>There are three types of execution contexts:</p><ol><li><strong>Global Execution Context (GEC)</strong>: The default or outermost context where the code starts running. There is only one global execution context.</li><li><strong>Function Execution Context (FEC)</strong>: Created every time a function is called.</li><li><strong>Eval Execution Context</strong>: Created when using <code>eval()</code> (though it is generally not recommended to use).</li></ol><p>When JavaScript code starts running, it starts with the <strong>Global Execution Context</strong>.</p><hr><h3 id="_2-the-call-stack" tabindex="-1"><strong>2. The Call Stack</strong> <a class="header-anchor" href="#_2-the-call-stack" aria-label="Permalink to “2. The Call Stack”">​</a></h3><p>The <strong>Call Stack</strong> is a stack data structure that keeps track of all the execution contexts (i.e., function calls) in the correct order. It follows the <strong>Last In, First Out (LIFO)</strong> principle, meaning the last function called is the first one to be executed.</p><ul><li>When a function is called, a new <strong>execution context</strong> is pushed onto the call stack.</li><li>When a function finishes executing, its execution context is popped off the stack, and control goes back to the previous execution context.</li></ul><h3 id="call-stack-example" tabindex="-1"><strong>Call Stack Example:</strong> <a class="header-anchor" href="#call-stack-example" aria-label="Permalink to “Call Stack Example:”">​</a></h3><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;First function&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Second function&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><ol><li>The global execution context is created and pushed onto the stack.</li><li>The <code>first()</code> function is called, so a new execution context for <code>first()</code> is pushed onto the stack.</li><li>Inside <code>first()</code>, the <code>second()</code> function is called, so a new execution context for <code>second()</code> is pushed onto the stack.</li><li><code>second()</code> finishes, and its execution context is popped off the stack.</li><li><code>first()</code> finishes, and its execution context is popped off the stack.</li><li>The global execution context finishes, and the stack is empty.</li></ol><hr><h3 id="_3-the-heap" tabindex="-1"><strong>3. The Heap</strong> <a class="header-anchor" href="#_3-the-heap" aria-label="Permalink to “3. The Heap”">​</a></h3><p><a href="https://www.youtube.com/watch?v=5OJRqkYbK-4&amp;t=79s&amp;ab_channel=AlexHyett" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=5OJRqkYbK-4&amp;t=79s&amp;ab_channel=AlexHyett</a></p><p>The <strong>Heap</strong> is an area in memory where objects are stored. It is used for dynamic memory allocation for objects, arrays, and other complex data types in JavaScript.</p><ul><li>When you create objects or arrays, they are stored in the heap.</li><li>Unlike the stack, the heap doesn’t follow a strict LIFO order; instead, it’s a large pool where memory is dynamically allocated and freed.</li></ul><p>For example, when you create a large object like an array or a function, the object is stored in the heap, while references to those objects are stored in the stack.</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`arr\` is stored in the stack, but the array is stored in the heap.</span></span></code></pre></div><hr><h3 id="_4-the-event-loop" tabindex="-1"><strong>4. The Event Loop</strong> <a class="header-anchor" href="#_4-the-event-loop" aria-label="Permalink to “4. The Event Loop”">​</a></h3><p><a href="https://www.youtube.com/watch?v=lqLSNG_79lI&amp;ab_channel=JamesQQuick" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=lqLSNG_79lI&amp;ab_channel=JamesQQuick</a></p><p>JavaScript is <strong>single-threaded</strong>, meaning it executes one task at a time. However, it can handle asynchronous code like <code>setTimeout()</code>, network requests, or event listeners without blocking the main thread. This is achieved using the <strong>Event Loop</strong> and <strong>Callback Queue</strong>.</p><p>Here’s how the <strong>Event Loop</strong> works:</p><ol><li><strong>Call Stack</strong>: JavaScript first executes all the tasks in the <strong>Call Stack</strong> (functions, code) one by one.</li><li><strong>Web APIs (Asynchronous APIs)</strong>: When an asynchronous operation is encountered (like <code>setTimeout</code>, <code>fetch</code>, or an event listener), it is sent to the browser&#39;s Web API environment (outside of the JavaScript engine).</li><li><strong>Callback Queue</strong>: Once the asynchronous task is completed (e.g., a <code>setTimeout</code> expires or a network request returns), its callback function is placed in the <strong>Callback Queue</strong>.</li><li><strong>Event Loop</strong>: The <strong>Event Loop</strong> constantly checks if the <strong>Call Stack</strong> is empty. If it is, it moves the callback from the <strong>Callback Queue</strong> to the <strong>Call Stack</strong> for execution.</li></ol><h3 id="event-loop-example" tabindex="-1"><strong>Event Loop Example:</strong> <a class="header-anchor" href="#event-loop-example" aria-label="Permalink to “Event Loop Example:”">​</a></h3><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Synchronous task</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Timeout 1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Asynchronous task</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Timeout 2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Asynchronous task</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;End&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Synchronous task</span></span></code></pre></div><p><strong>Execution Order:</strong></p><ol><li><code>Start</code> is logged.</li><li>The first <code>setTimeout</code> is sent to the Web API, and the callback is placed in the Callback Queue after 0 ms.</li><li>The second <code>setTimeout</code> is sent to the Web API, and the callback is placed in the Callback Queue after 0 ms.</li><li><code>End</code> is logged.</li><li>The <strong>Call Stack</strong> is empty, so the Event Loop picks the first callback (<code>Timeout 1</code>) from the Callback Queue and places it in the Call Stack to execute.</li><li><code>Timeout 1</code> is logged.</li><li>The Event Loop picks the second callback (<code>Timeout 2</code>) from the Callback Queue and places it in the Call Stack to execute.</li><li><code>Timeout 2</code> is logged.</li></ol><p><strong>Output:</strong></p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Start</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">End</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Timeout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Timeout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div><p>Notice that even though <code>setTimeout</code> was set to 0 milliseconds, the callbacks were executed after all synchronous code (<code>console.log(&#39;Start&#39;)</code> and <code>console.log(&#39;End&#39;)</code>).</p><hr><h3 id="_5-memory-management-and-garbage-collection" tabindex="-1"><strong>5. Memory Management and Garbage Collection</strong> <a class="header-anchor" href="#_5-memory-management-and-garbage-collection" aria-label="Permalink to “5. Memory Management and Garbage Collection”">​</a></h3><p><a href="https://www.youtube.com/watch?v=FZ42HMWG6xg&amp;ab_channel=DanShykhov" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=FZ42HMWG6xg&amp;ab_channel=DanShykhov</a></p><p>JavaScript automatically handles memory management, and it has a <strong>Garbage Collector</strong> that reclaims memory that is no longer in use. It does this by identifying objects that are no longer referenced and freeing up memory to avoid memory leaks.</p><ul><li>When an object is no longer reachable (no reference to it exists), the garbage collector will mark it for cleanup and free the memory.</li></ul><hr><h3 id="_6-execution-phases-in-detail" tabindex="-1"><strong>6. Execution Phases in Detail</strong> <a class="header-anchor" href="#_6-execution-phases-in-detail" aria-label="Permalink to “6. Execution Phases in Detail”">​</a></h3><p><a href="https://www.youtube.com/watch?v=UmcJktbZOGM&amp;ab_channel=procademy" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=UmcJktbZOGM&amp;ab_channel=procademy</a></p><p>The <strong>execution of JavaScript</strong> can be divided into phases:</p><h3 id="_1-compilation-phase" tabindex="-1"><strong>1. Compilation Phase:</strong> <a class="header-anchor" href="#_1-compilation-phase" aria-label="Permalink to “1. Compilation Phase:”">​</a></h3><ul><li>JavaScript first parses the entire code and compiles it. This includes: <ul><li><strong>Hoisting</strong>: JavaScript moves <strong>declarations</strong> (variables and functions) to the top of their respective scopes.</li><li><strong>Creation of Execution Context</strong>: The code is divided into different execution contexts (Global, Function).</li></ul></li></ul><h3 id="_2-execution-phase" tabindex="-1"><strong>2. Execution Phase:</strong> <a class="header-anchor" href="#_2-execution-phase" aria-label="Permalink to “2. Execution Phase:”">​</a></h3><ul><li>After compilation, JavaScript starts executing the code: <ul><li><strong>Global Execution Context</strong> is executed first.</li><li>When a function is invoked, a new <strong>Function Execution Context</strong> is created and pushed onto the Call Stack.</li></ul></li></ul><hr><h3 id="summary-of-the-execution-process" tabindex="-1"><strong>Summary of the Execution Process:</strong> <a class="header-anchor" href="#summary-of-the-execution-process" aria-label="Permalink to “Summary of the Execution Process:”">​</a></h3><ol><li><strong>Compilation Phase</strong>: <ul><li>Code is parsed, and <strong>execution contexts</strong> are created.</li><li><strong>Declarations</strong> are hoisted (variables and functions).</li></ul></li><li><strong>Execution Phase</strong>: <ul><li>The <strong>Call Stack</strong> starts running the code, executing synchronously.</li><li>If an <strong>asynchronous task</strong> is encountered, it’s sent to the <strong>Web API</strong>, and its callback is placed in the <strong>Callback Queue</strong> when ready.</li><li>The <strong>Event Loop</strong> checks if the <strong>Call Stack</strong> is empty and moves tasks from the <strong>Callback Queue</strong> to the <strong>Call Stack</strong> for execution.</li></ul></li><li><strong>Garbage Collection</strong>: <ul><li>Unused variables and objects are cleaned up by the <strong>Garbage Collector</strong>.</li></ul></li></ol><hr><h3 id="conclusion" tabindex="-1"><strong>Conclusion</strong> <a class="header-anchor" href="#conclusion" aria-label="Permalink to “Conclusion”">​</a></h3><ul><li><strong>Call Stack</strong>: Handles synchronous code execution.</li><li><strong>Heap</strong>: Stores objects and arrays.</li><li><strong>Event Loop</strong>: Allows asynchronous code to be handled without blocking the main thread.</li><li><strong>Execution Context</strong>: Manages the environment for the execution of code.</li><li><strong>Garbage Collection</strong>: Cleans up unused memory.</li></ul><p>This mechanism ensures that JavaScript can handle both synchronous and asynchronous tasks efficiently while maintaining a single-threaded execution model.</p>`,59)])])}const g=s(n,[["render",o]]);export{k as __pageData,g as default};
