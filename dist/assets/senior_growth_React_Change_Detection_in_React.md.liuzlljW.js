import{_ as t,c as i,o as a,af as n}from"./chunks/framework.C3eVOF8n.js";const g=JSON.parse('{"title":"Change Detection in React","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/React/Change_Detection_in_React.md","filePath":"senior_growth/React/Change_Detection_in_React.md"}'),s={name:"senior_growth/React/Change_Detection_in_React.md"};function o(r,e,l,c,h,d){return a(),i("div",null,[...e[0]||(e[0]=[n('<h1 id="change-detection-in-react" tabindex="-1">Change Detection in React <a class="header-anchor" href="#change-detection-in-react" aria-label="Permalink to “Change Detection in React”">​</a></h1><p>Subjects: React</p><h3 id="how-change-detection-works-in-react" tabindex="-1"><strong>How Change Detection Works in React</strong> <a class="header-anchor" href="#how-change-detection-works-in-react" aria-label="Permalink to “How Change Detection Works in React”">​</a></h3><ol><li><p><strong>State or Props Changes</strong>:</p><ul><li>React components re-render whenever their state or props change. These changes trigger the component&#39;s <code>render()</code> method to generate a new Virtual DOM tree.</li></ul></li><li><p><strong>Virtual DOM and Diffing</strong>:</p><ul><li>A new Virtual DOM tree is created based on the updated state or props.</li><li>React compares the new Virtual DOM tree with the previous one using its <strong>diffing algorithm</strong>. This comparison identifies the minimum changes required to update the real DOM.</li></ul></li><li><p><strong>Efficient DOM Updates</strong>:</p><ul><li>React batches and applies the necessary changes to the real DOM in a single operation, minimizing the overhead associated with DOM manipulation.</li></ul></li><li><p><strong>Component Update Control</strong>:</p><ul><li>Developers can control updates using methods like <code>shouldComponentUpdate</code> (class components) or <code>React.memo</code> (functional components). This reduces unnecessary renders.</li></ul><p><code>shouldComponentUpdate</code> nem tul ismeros!</p><p><a href="https://www.youtube.com/watch?v=40Bq8kOKB74&amp;ab_channel=DavidParker" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=40Bq8kOKB74&amp;ab_channel=DavidParker</a></p></li></ol><h3 id="key-mechanisms-enabling-change-detection" tabindex="-1"><strong>Key Mechanisms Enabling Change Detection</strong> <a class="header-anchor" href="#key-mechanisms-enabling-change-detection" aria-label="Permalink to “Key Mechanisms Enabling Change Detection”">​</a></h3><ol><li><p><strong>Immutable State</strong>:</p><ul><li><p>React relies on immutability to detect changes. If the state or props change, React assumes a new object is created and performs reconciliation.</p></li><li><p>Example:</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldState, key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;newValue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Triggers re-render</span></span></code></pre></div></li></ul></li><li><p><strong>Unidirectional Data Flow</strong>:</p><ul><li>React&#39;s one-way data flow ensures that changes propagate predictably, from parent to child components. Each component decides how to handle changes to its props or state.</li></ul></li><li><p><strong>Fiber Architecture</strong>:</p><ul><li>Fiber allows React to break the rendering work into smaller units. It prioritizes tasks like animations or user input, enabling smoother updates in complex applications.</li></ul><p><a href="https://www.youtube.com/watch?v=0ympFIwQFJw&amp;ab_channel=PhilipFabianek" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=0ympFIwQFJw&amp;ab_channel=PhilipFabianek</a></p></li></ol><h2 id="reconciliation-algorithm-in-react" tabindex="-1">Reconciliation Algorithm in React <a class="header-anchor" href="#reconciliation-algorithm-in-react" aria-label="Permalink to “Reconciliation Algorithm in React”">​</a></h2><ol><li><strong>Diffing Algorithm</strong>: <ul><li>React compares the new Virtual DOM with the previous one (diffing).</li><li>Changes are tracked at the node level (e.g., element type, attributes, children).</li></ul></li><li><strong>Key Optimizations</strong>: <ul><li><strong>Element Type Comparison</strong>: If the types of two nodes (e.g., <code>&lt;div&gt;</code> vs <code>&lt;p&gt;</code>) differ, React replaces the old node entirely.</li><li><strong>Props and State Updates</strong>: React shallowly compares props and state to determine what has changed.</li><li><strong>Keys for Lists</strong>: Keys are crucial for efficient updates in lists. React uses keys to match elements between renders, avoiding unnecessary re-renders or element destruction.</li></ul></li><li><strong>Fiber Architecture</strong> (Introduced in React 16): <ul><li>React&#39;s Fiber is a reimplementation of its reconciliation algorithm.</li><li>It breaks rendering into units of work, allowing React to pause and resume rendering.</li><li>Improves performance for large and complex applications by prioritizing tasks (e.g., animations are updated faster than off-screen updates).</li></ul></li></ol><h3 id="trade-offs-of-react-s-change-detection-mechanism" tabindex="-1"><strong>Trade-offs of React&#39;s Change Detection Mechanism</strong> <a class="header-anchor" href="#trade-offs-of-react-s-change-detection-mechanism" aria-label="Permalink to “Trade-offs of React&#39;s Change Detection Mechanism”">​</a></h3><h3 id="_1-benefits" tabindex="-1"><strong>1. Benefits:</strong> <a class="header-anchor" href="#_1-benefits" aria-label="Permalink to “1. Benefits:”">​</a></h3><ol><li><strong>Performance</strong>: <ul><li>The Virtual DOM and reconciliation process minimize expensive real DOM manipulations, enhancing performance, especially for dynamic applications.</li></ul></li><li><strong>Declarative Code</strong>: <ul><li>React’s declarative approach abstracts away the complexity of managing manual DOM updates.</li></ul></li><li><strong>Scalability</strong>: <ul><li>React’s diffing and reconciliation scales well with large, component-based applications.</li></ul></li><li><strong>Predictability</strong>: <ul><li>By relying on immutability and unidirectional data flow, React ensures consistent updates without side effects.</li></ul></li></ol><h3 id="_2-trade-offs" tabindex="-1"><strong>2. Trade-offs:</strong> <a class="header-anchor" href="#_2-trade-offs" aria-label="Permalink to “2. Trade-offs:”">​</a></h3><ol><li><strong>Reconciliation Overhead</strong>: <ul><li>The diffing process, while efficient, still adds computational overhead. For extremely frequent updates, this might be a bottleneck.</li></ul></li><li><strong>Learning Curve</strong>: <ul><li>React’s model, especially with advanced optimization techniques (<code>React.memo</code>, <code>useCallback</code>, etc.), requires developers to think differently compared to frameworks with two-way data binding (e.g., Angular).</li></ul></li><li><strong>Not Always the Fastest</strong>: <ul><li>For simple applications with minimal DOM updates, React’s Virtual DOM abstraction can be slower than direct DOM manipulations in vanilla JavaScript.</li></ul></li><li><strong>Memory Usage</strong>: <ul><li>Storing multiple Virtual DOM trees and intermediate objects increases memory consumption.</li></ul></li></ol>',13)])])}const m=t(s,[["render",o]]);export{g as __pageData,m as default};
