# What is a Promise?

Subjects: General ES6+

A **Promise** in JavaScript is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It is a modern way to handle asynchronous code, providing a cleaner alternative to callback-based approaches.

---

https://www.youtube.com/watch?v=RvYYCGs45L4&ab_channel=Fireship

https://www.youtube.com/watch?v=li7FzDHYZpc&ab_channel=RobertsDevTalk

### **Key Features of Promises**

1. **Asynchronous Handling**:
Promises help manage asynchronous code in a readable and maintainable way.
2. **Immutable State**:
Once a promise is resolved (fulfilled or rejected), its state cannot be changed.
3. **Avoids Callback Hell**:
Promises prevent deeply nested callbacks by chaining `.then()` handlers.

---

### **The States of a Promise**

A Promise has three possible states:

1. **Pending**: The initial state. The asynchronous operation is still in progress.
2. **Fulfilled**: The operation completed successfully, and the promise has a resulting value.
3. **Rejected**: The operation failed, and the promise has a reason (error).

---

### **How to Create a Promise**

A Promise is created using the `Promise` constructor, which takes an **executor function** as an argument. The executor function has two parameters: `resolve` and `reject`, which are used to determine the outcome of the promise.

**Syntax:**

```jsx
const promise = new Promise((resolve, reject) => {
  // Perform some asynchronous operation
  let success = true; // Simulated outcome

  if (success) {
    resolve("Operation was successful!"); // Fulfill the promise
  } else {
    reject("Operation failed!"); // Reject the promise
  }
});

```

---

### **Using Promises**

Promises are used with `.then()`, `.catch()`, and `.finally()` methods.

### **1. `then()`**

Handles the resolved value (success).

```jsx
promise.then((result) => {
  console.log(result); // Output: "Operation was successful!"
});

```

### **2. `catch()`**

Handles errors (rejections).

```jsx
promise.catch((error) => {
  console.error(error); // Output: "Operation failed!"
});

```

### **3. `finally()`**

Executes code regardless of the outcome (whether resolved or rejected).

```jsx
promise.finally(() => {
  console.log("Operation is complete!");
});

```

---

### **Example: A Promise in Action**

Here's an example simulating a delayed operation using `setTimeout`:

```jsx
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true; // Simulate success or failure
    if (success) {
      resolve("Data fetched successfully!");
    } else {
      reject("Failed to fetch data.");
    }
  }, 2000); // Simulate a 2-second delay
});

fetchData
  .then((data) => {
    console.log(data); // Output: "Data fetched successfully!"
  })
  .catch((error) => {
    console.error(error); // Output: "Failed to fetch data."
  })
  .finally(() => {
    console.log("Operation complete."); // Runs regardless of success or failure
  });

```

---

### **Promise Chaining**

Promises can be chained for sequential operations, making asynchronous workflows more readable.

**Example:**

```jsx
fetchUserData()
  .then((user) => {
    console.log("User data:", user);
    return fetchUserPosts(user.id); // Return another promise
  })
  .then((posts) => {
    console.log("User posts:", posts);
  })
  .catch((error) => {
    console.error("Error:", error);
  });

```

---

### **Promise Methods**

### 1. **`Promise.all()`**

Waits for all promises in an array to resolve. If one promise rejects, the entire `Promise.all` rejects.

```jsx
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // Array of resolved values
  })
  .catch((error) => {
    console.error(error); // Error from the first rejected promise
  });
```

### 2. **`Promise.race()`**

Resolves or rejects as soon as the first promise in the array is settled.

```jsx
Promise.race([promise1, promise2, promise3])
  .then((result) => {
    console.log(result); // Result of the first resolved promise
  })
  .catch((error) => {
    console.error(error); // Error of the first rejected promise
  });
```

### 3. **`Promise.allSettled()`**

Waits for all promises to settle (resolve or reject) and returns their results.

```jsx
Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  console.log(results); // Array of objects with `status` and `value`/`reason`
});
```

### 4. **`Promise.any()`**

Waits for the first fulfilled promise. If all promises reject, it returns an AggregateError.

```jsx
Promise.any([promise1, promise2, promise3])
  .then((result) => {
    console.log(result); // Result of the first fulfilled promise
  })
  .catch((error) => {
    console.error(error); // AggregateError if all promises are rejected
  });
```

---

### **Why Use Promises?**

1. **Readable Asynchronous Code**: Promises improve readability compared to deeply nested callbacks.
2. **Error Handling**: Centralized error handling using `.catch()` simplifies debugging.
3. **Chaining**: Promises allow for chaining multiple asynchronous operations in sequence.
4. **Compatibility**: Promises are widely supported and can be integrated with modern async/await syntax.

---

### **Promise vs Async/Await**

While Promises are powerful, they are often used with `async/await` for even cleaner and more synchronous-looking code. Promises remain the underlying mechanism behind `async/await`.

---