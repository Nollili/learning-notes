import{_ as s,c as a,o as e,af as t}from"./chunks/framework.C3eVOF8n.js";const c=JSON.parse('{"title":"ğŸ”„ Polling vs WebSockets â€” Real-Time Communication","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/Communication_and_Security/What_is_polling_and_what_is_websocket_websockets_vs_polling.md","filePath":"senior_growth/Communication_and_Security/What_is_polling_and_what_is_websocket_websockets_vs_polling.md"}'),n={name:"senior_growth/Communication_and_Security/What_is_polling_and_what_is_websocket_websockets_vs_polling.md"};function l(r,i,h,o,d,p){return e(),a("div",null,[...i[0]||(i[0]=[t(`<h1 id="ğŸ”„-polling-vs-websockets-â€”-real-time-communication" tabindex="-1">ğŸ”„ Polling vs WebSockets â€” Real-Time Communication <a class="header-anchor" href="#ğŸ”„-polling-vs-websockets-â€”-real-time-communication" aria-label="Permalink to â€œğŸ”„ Polling vs WebSockets â€” Real-Time Communicationâ€">â€‹</a></h1><p>Modern web apps often need to <strong>receive updates from the server in real-time</strong>. Two common approaches are <strong>polling</strong> and <strong>WebSockets</strong>.</p><hr><h2 id="_1ï¸âƒ£-polling" tabindex="-1">1ï¸âƒ£ Polling <a class="header-anchor" href="#_1ï¸âƒ£-polling" aria-label="Permalink to â€œ1ï¸âƒ£ Pollingâ€">â€‹</a></h2><h3 id="ğŸ”‘-what-it-is" tabindex="-1">ğŸ”‘ What It Is <a class="header-anchor" href="#ğŸ”‘-what-it-is" aria-label="Permalink to â€œğŸ”‘ What It Isâ€">â€‹</a></h3><p>Polling is a technique where the client <strong>repeatedly sends HTTP requests</strong> to the server at regular intervals to check for updates.</p><p><strong>Example:</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/api/notifications&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateUI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// every 5 seconds</span></span></code></pre></div><h3 id="âœ…-advantages" tabindex="-1">âœ… Advantages <a class="header-anchor" href="#âœ…-advantages" aria-label="Permalink to â€œâœ… Advantagesâ€">â€‹</a></h3><ul><li>Simple to implement.</li><li>Works with <strong>all browsers</strong> and standard HTTP.</li><li>No special server setup required.</li></ul><h3 id="âŒ-disadvantages" tabindex="-1">âŒ Disadvantages <a class="header-anchor" href="#âŒ-disadvantages" aria-label="Permalink to â€œâŒ Disadvantagesâ€">â€‹</a></h3><ul><li>High overhead â†’ repeated HTTP headers, multiple connections.</li><li>Latency â†’ updates are only received on the next poll.</li><li>Wastes server and network resources if data rarely changes.</li><li>Does not scale well for many users.</li></ul><hr><h2 id="_2ï¸âƒ£-websockets" tabindex="-1">2ï¸âƒ£ WebSockets <a class="header-anchor" href="#_2ï¸âƒ£-websockets" aria-label="Permalink to â€œ2ï¸âƒ£ WebSocketsâ€">â€‹</a></h2><h3 id="ğŸ”‘-what-it-is-1" tabindex="-1">ğŸ”‘ What It Is <a class="header-anchor" href="#ğŸ”‘-what-it-is-1" aria-label="Permalink to â€œğŸ”‘ What It Isâ€">â€‹</a></h3><p>WebSockets provide a <strong>persistent, full-duplex TCP connection</strong> between client and server.</p><ul><li>Client initiates handshake:</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;wss://example.com/updates&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateUI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data));</span></span></code></pre></div><ul><li>Server can push updates <strong>instantly</strong> whenever they occur.</li></ul><h3 id="âœ…-advantages-1" tabindex="-1">âœ… Advantages <a class="header-anchor" href="#âœ…-advantages-1" aria-label="Permalink to â€œâœ… Advantagesâ€">â€‹</a></h3><ul><li>Low latency â†’ instant updates.</li><li>Bi-directional â†’ client and server can send messages any time.</li><li>Efficient â†’ single connection, no repeated headers.</li><li>Scales better for real-time applications.</li></ul><h3 id="âŒ-disadvantages-1" tabindex="-1">âŒ Disadvantages <a class="header-anchor" href="#âŒ-disadvantages-1" aria-label="Permalink to â€œâŒ Disadvantagesâ€">â€‹</a></h3><ul><li>More complex to implement on backend.</li><li>Stateful â†’ harder to scale horizontally.</li><li>Some proxies/firewalls may block persistent connections.</li><li>Requires HTTPS (<code>wss://</code>) for security.</li></ul><hr><h2 id="âš–ï¸-polling-vs-websockets-â€”-comparison-table" tabindex="-1">âš–ï¸ Polling vs WebSockets â€” Comparison Table <a class="header-anchor" href="#âš–ï¸-polling-vs-websockets-â€”-comparison-table" aria-label="Permalink to â€œâš–ï¸ Polling vs WebSockets â€” Comparison Tableâ€">â€‹</a></h2><table tabindex="0"><thead><tr><th>Feature</th><th>Polling</th><th>WebSockets</th></tr></thead><tbody><tr><td>Connection</td><td>Short-lived per request</td><td>Persistent</td></tr><tr><td>Communication</td><td>Client â†’ Server only</td><td>Bi-directional</td></tr><tr><td>Latency</td><td>High (depends on interval)</td><td>Low (real-time)</td></tr><tr><td>Efficiency</td><td>Low â€” repeated requests</td><td>High â€” single connection</td></tr><tr><td>Complexity</td><td>Simple</td><td>More complex</td></tr><tr><td>Scalability</td><td>Poor for many users</td><td>Better with proper backend</td></tr><tr><td>Browser Support</td><td>Universal</td><td>Modern browsers</td></tr><tr><td>Security</td><td>HTTPS optional</td><td>WSS recommended</td></tr><tr><td>Use Cases</td><td>Non-critical updates</td><td>Chat, live dashboards, notifications, games</td></tr></tbody></table><hr><h2 id="ğŸ§ -best-practices" tabindex="-1">ğŸ§  Best Practices <a class="header-anchor" href="#ğŸ§ -best-practices" aria-label="Permalink to â€œğŸ§  Best Practicesâ€">â€‹</a></h2><ul><li><p>Use <strong>polling</strong> for:</p><ul><li>Infrequent updates</li><li>Legacy browsers</li><li>Simple apps where real-time data isnâ€™t critical</li></ul></li><li><p>Use <strong>WebSockets</strong> for:</p><ul><li>Real-time applications (chat, notifications, live dashboards)</li><li>High-frequency updates</li><li>Bidirectional communication needs</li></ul></li><li><p><strong>Hybrid approach:</strong></p><ul><li>Initial load via REST/HTTP, real-time updates via WebSocket.</li></ul></li></ul><hr><blockquote><p><strong>Rule of Thumb:</strong> Polling â†’ simple, low-frequency updates. WebSockets â†’ efficient, real-time, high-frequency, bidirectional communication.</p></blockquote>`,31)])])}const g=s(n,[["render",l]]);export{c as __pageData,g as default};
