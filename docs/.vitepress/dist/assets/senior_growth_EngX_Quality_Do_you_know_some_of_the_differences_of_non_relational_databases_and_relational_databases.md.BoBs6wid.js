import{_ as t,c as e,o as s,af as n}from"./chunks/framework.C3eVOF8n.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/EngX_Quality/Do_you_know_some_of_the_differences_of_non_relational_databases_and_relational_databases.md","filePath":"senior_growth/EngX_Quality/Do_you_know_some_of_the_differences_of_non_relational_databases_and_relational_databases.md"}'),o={name:"senior_growth/EngX_Quality/Do_you_know_some_of_the_differences_of_non_relational_databases_and_relational_databases.md"};function r(i,a,l,d,c,g){return s(),e("div",null,[...a[0]||(a[0]=[n('<h3 id="do-you-know-some-of-the-differences-of-non-relational-databases-and-relational-databases" tabindex="-1">Do you know some of the differences of non relational databases and relational databases? <a class="header-anchor" href="#do-you-know-some-of-the-differences-of-non-relational-databases-and-relational-databases" aria-label="Permalink to “Do you know some of the differences of non relational databases and relational databases?”">​</a></h3><p>Yes, relational databases (RDBMS) and non-relational databases (NoSQL) differ in several key aspects related to their data models, structure, scalability, and usage. Here’s a comparison:</p><h3 id="_1-data-model" tabindex="-1"><strong>1. Data Model</strong> <a class="header-anchor" href="#_1-data-model" aria-label="Permalink to “1. Data Model”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>Structured Data</strong>: Data is stored in tables with predefined schemas consisting of rows and columns.</li><li><strong>Schema-based</strong>: Requires a fixed schema that defines the types and structure of data. Tables are linked with foreign keys.</li><li><strong>Examples</strong>: MySQL, PostgreSQL, Oracle, Microsoft SQL Server.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Flexible Schema</strong>: Can handle unstructured, semi-structured, or structured data. Some NoSQL databases are schema-less or allow dynamic schema.</li><li><strong>Data Types</strong>: NoSQL databases support various models like key-value pairs, document stores, wide-column stores, and graph databases.</li><li><strong>Examples</strong>: MongoDB (document), Cassandra (wide-column), Redis (key-value), Neo4j (graph).</li></ul></li></ul><hr><h3 id="_2-data-structure" tabindex="-1"><strong>2. Data Structure</strong> <a class="header-anchor" href="#_2-data-structure" aria-label="Permalink to “2. Data Structure”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>Tables</strong>: Data is stored in tables with rows (records) and columns (attributes).</li><li><strong>Relationships</strong>: Supports relationships between tables using <strong>Primary Keys</strong> and <strong>Foreign Keys</strong>.</li><li><strong>Normalization</strong>: Data is typically normalized to minimize redundancy and ensure data integrity.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Key-Value Stores</strong>: Data is stored as key-value pairs, useful for fast lookups.</li><li><strong>Document Stores</strong>: Data is stored as documents (often JSON or BSON), which can have nested structures.</li><li><strong>Wide-Column Stores</strong>: Data is stored in rows and columns, but columns are grouped into families, providing more flexibility.</li><li><strong>Graph Databases</strong>: Data is stored in graphs with nodes, edges, and properties, used for connected data.</li><li><strong>Flexible Schema</strong>: NoSQL databases can store data without a fixed schema, which can be beneficial for evolving datasets.</li></ul></li></ul><hr><h3 id="_3-scalability" tabindex="-1"><strong>3. Scalability</strong> <a class="header-anchor" href="#_3-scalability" aria-label="Permalink to “3. Scalability”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>Vertical Scaling</strong>: RDBMS typically scale vertically by adding more power to the server (CPU, RAM, etc.).</li><li><strong>Challenges with Scaling</strong>: As the data grows, scaling RDBMS can become expensive and less efficient due to the need for powerful hardware and more complex database administration.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Horizontal Scaling</strong>: NoSQL databases are designed to scale horizontally by adding more servers (nodes) to distribute the load, making them more efficient for large-scale, distributed applications.</li><li><strong>Better for Big Data</strong>: NoSQL databases are better suited for high-volume, low-latency applications, and can handle large amounts of unstructured data.</li></ul></li></ul><hr><h3 id="_4-consistency-and-transactions" tabindex="-1"><strong>4. Consistency and Transactions</strong> <a class="header-anchor" href="#_4-consistency-and-transactions" aria-label="Permalink to “4. Consistency and Transactions”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>ACID Compliance</strong>: RDBMS follow <strong>ACID</strong> (Atomicity, Consistency, Isolation, Durability) principles to ensure reliable transactions.</li><li><strong>Strong Consistency</strong>: Ensures that transactions are consistent, reliable, and follow strict rules.</li><li><strong>Transactions</strong>: Supports complex transactions with multiple operations that can be rolled back if needed.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Eventual Consistency</strong>: Many NoSQL databases adopt <strong>eventual consistency</strong> rather than strict ACID properties, especially in distributed systems. This means data may not be immediately consistent across all nodes.</li><li><strong>CAP Theorem</strong>: NoSQL databases often follow the <strong>CAP Theorem</strong> (Consistency, Availability, Partition tolerance), which means they prioritize availability and partition tolerance over strict consistency in distributed systems.</li><li><strong>Limited Transactions</strong>: Some NoSQL databases support transactions at the document or collection level, but they do not offer the same level of transactional consistency as RDBMS.</li></ul></li></ul><hr><h3 id="_5-querying-and-flexibility" tabindex="-1"><strong>5. Querying and Flexibility</strong> <a class="header-anchor" href="#_5-querying-and-flexibility" aria-label="Permalink to “5. Querying and Flexibility”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>SQL</strong>: Uses <strong>Structured Query Language (SQL)</strong> for querying, which is powerful and standardized across relational systems.</li><li><strong>Complex Queries</strong>: RDBMS are ideal for complex queries with multiple joins, subqueries, and aggregations.</li><li><strong>Fixed Schema</strong>: Data must fit into a fixed schema, which can limit flexibility when data changes frequently.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Varied Query Languages</strong>: NoSQL databases have different query languages and methods depending on the database type (e.g., MongoDB uses a query language that operates on documents, while Redis uses simple key-based queries).</li><li><strong>Schema-less</strong>: NoSQL allows for flexible data models that can evolve over time, which is useful for applications with rapidly changing data.</li><li><strong>Scalability vs. Complexity</strong>: While NoSQL is more flexible, it can be harder to perform complex queries involving joins or aggregations.</li></ul></li></ul><hr><h3 id="_6-use-cases" tabindex="-1"><strong>6. Use Cases</strong> <a class="header-anchor" href="#_6-use-cases" aria-label="Permalink to “6. Use Cases”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>Best for structured data</strong>: Applications that require structured data and relationships, such as financial systems, ERP systems, and transactional applications.</li><li><strong>Strong Data Integrity</strong>: Ideal for applications that require strong consistency and ACID transactions (e.g., banking, inventory systems).</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Big Data</strong>: Well-suited for handling large volumes of unstructured or semi-structured data, such as social media platforms, IoT data, and logs.</li><li><strong>Real-Time Applications</strong>: Often used in applications that require fast data ingestion and retrieval, such as real-time analytics, recommendation engines, and content management systems.</li><li><strong>Flexible and Evolving Data</strong>: Ideal for applications with evolving data structures, where the schema may change over time, like e-commerce platforms, content management, and social media apps.</li></ul></li></ul><hr><h3 id="_7-performance" tabindex="-1"><strong>7. Performance</strong> <a class="header-anchor" href="#_7-performance" aria-label="Permalink to “7. Performance”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>Optimized for Transactional Workloads</strong>: RDBMS are optimized for transactional workloads where data integrity is critical.</li><li><strong>Complex Queries</strong>: RDBMS tend to perform well for complex queries, aggregations, and data analysis.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>Optimized for Horizontal Scaling</strong>: NoSQL databases can handle huge amounts of data and scale easily, making them better for high-volume, low-latency applications.</li><li><strong>Fast Writes</strong>: NoSQL databases are generally optimized for fast writes, making them suitable for real-time data processing and logging.</li></ul></li></ul><hr><h3 id="_8-examples-and-specifics" tabindex="-1"><strong>8. Examples and Specifics</strong> <a class="header-anchor" href="#_8-examples-and-specifics" aria-label="Permalink to “8. Examples and Specifics”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong>: <ul><li><strong>MySQL</strong>: Popular for web applications and content management systems.</li><li><strong>PostgreSQL</strong>: Known for its strong consistency and extensibility, used in analytics, geospatial data, and more.</li><li><strong>Oracle Database</strong>: Enterprise-level RDBMS widely used for business applications with complex requirements.</li></ul></li><li><strong>Non-relational Databases (NoSQL)</strong>: <ul><li><strong>MongoDB</strong>: A document store that is easy to scale and provides a flexible schema for JSON-like data.</li><li><strong>Cassandra</strong>: A distributed, wide-column store designed for high availability and massive scalability.</li><li><strong>Redis</strong>: A fast, in-memory key-value store often used for caching, session storage, and real-time analytics.</li><li><strong>Neo4j</strong>: A graph database used to store data in a graph format (e.g., for social networks, fraud detection).</li></ul></li></ul><hr><h3 id="summary-table" tabindex="-1"><strong>Summary Table</strong> <a class="header-anchor" href="#summary-table" aria-label="Permalink to “Summary Table”">​</a></h3><table tabindex="0"><thead><tr><th><strong>Aspect</strong></th><th><strong>Relational Databases (RDBMS)</strong></th><th><strong>Non-relational Databases (NoSQL)</strong></th></tr></thead><tbody><tr><td><strong>Data Structure</strong></td><td>Tables, rows, columns</td><td>Flexible structures (documents, key-value, graphs, wide-column)</td></tr><tr><td><strong>Schema</strong></td><td>Fixed schema, rigid</td><td>Dynamic or schema-less</td></tr><tr><td><strong>Query Language</strong></td><td>SQL</td><td>Varies (depends on DB type)</td></tr><tr><td><strong>Scalability</strong></td><td>Vertical scaling (difficult)</td><td>Horizontal scaling (easy)</td></tr><tr><td><strong>Consistency</strong></td><td>ACID compliant (strong)</td><td>Eventual consistency (CAP Theorem)</td></tr><tr><td><strong>Transactions</strong></td><td>Full ACID transactions</td><td>Limited or no ACID support</td></tr><tr><td><strong>Best Use Case</strong></td><td>Structured, transactional data</td><td>Large-scale, unstructured data</td></tr><tr><td><strong>Examples</strong></td><td>MySQL, PostgreSQL, Oracle</td><td>MongoDB, Cassandra, Redis, Neo4j</td></tr></tbody></table><hr><h3 id="conclusion" tabindex="-1"><strong>Conclusion</strong> <a class="header-anchor" href="#conclusion" aria-label="Permalink to “Conclusion”">​</a></h3><ul><li><strong>Relational Databases (RDBMS)</strong> are best suited for applications with structured data, complex relationships, and strong transactional requirements. They excel in scenarios where data integrity, consistency, and complex queries are crucial.</li><li><strong>Non-relational Databases (NoSQL)</strong> are better for handling large volumes of unstructured or semi-structured data, real-time analytics, or applications that need horizontal scalability. They are more flexible in terms of schema and can handle distributed, high-availability use cases.</li></ul>',31)])])}const m=t(o,[["render",r]]);export{h as __pageData,m as default};
