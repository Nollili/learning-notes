import{_ as i,c as e,o as a,af as t}from"./chunks/framework.C3eVOF8n.js";const c=JSON.parse('{"title":"What are the usual sources of problems with memory?","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/Web_Performance/What_are_the_usual_source_of_problems_with_memory.md","filePath":"senior_growth/Web_Performance/What_are_the_usual_source_of_problems_with_memory.md"}'),n={name:"senior_growth/Web_Performance/What_are_the_usual_source_of_problems_with_memory.md"};function r(l,s,h,o,k,p){return a(),e("div",null,[...s[0]||(s[0]=[t(`<h1 id="what-are-the-usual-sources-of-problems-with-memory" tabindex="-1">What are the usual sources of problems with memory? <a class="header-anchor" href="#what-are-the-usual-sources-of-problems-with-memory" aria-label="Permalink to ‚ÄúWhat are the usual sources of problems with memory?‚Äù">‚Äã</a></h1><h2 id="common-sources-of-memory-problems-in-front-end-applications" tabindex="-1">Common Sources of Memory Problems in Front-End Applications <a class="header-anchor" href="#common-sources-of-memory-problems-in-front-end-applications" aria-label="Permalink to ‚ÄúCommon Sources of Memory Problems in Front-End Applications‚Äù">‚Äã</a></h2><p>Memory problems in web applications often occur when <strong>unused objects remain referenced</strong>, preventing the <strong>JavaScript garbage collector (GC)</strong> from reclaiming memory.<br> This can result in <strong>memory leaks</strong>, <strong>increased heap size</strong>, and <strong>slower performance</strong> ‚Äî especially in long-running single-page applications (SPAs).</p><hr><h2 id="üß†-quick-refresher-how-garbage-collection-works" tabindex="-1">üß† Quick Refresher: How Garbage Collection Works <a class="header-anchor" href="#üß†-quick-refresher-how-garbage-collection-works" aria-label="Permalink to ‚Äúüß† Quick Refresher: How Garbage Collection Works‚Äù">‚Äã</a></h2><ul><li>JavaScript uses <strong>automatic garbage collection</strong> with a <strong>mark-and-sweep</strong> algorithm.</li><li>The GC only removes objects that are <strong>no longer reachable</strong> from the root scope (like <code>window</code> or <code>document</code>).</li></ul><p>üí° <strong>If something is still referenced</strong>, even indirectly, it will <strong>not be collected</strong>.</p><hr><h2 id="‚ö†Ô∏è-common-sources-of-memory-problems" tabindex="-1">‚ö†Ô∏è Common Sources of Memory Problems <a class="header-anchor" href="#‚ö†Ô∏è-common-sources-of-memory-problems" aria-label="Permalink to ‚Äú‚ö†Ô∏è Common Sources of Memory Problems‚Äù">‚Äã</a></h2><h3 id="_1-forgotten-event-listeners" tabindex="-1">1. Forgotten Event Listeners <a class="header-anchor" href="#_1-forgotten-event-listeners" aria-label="Permalink to ‚Äú1. Forgotten Event Listeners‚Äù">‚Äã</a></h3><p>Event handlers attached to DOM elements that are later removed can stay in memory if not properly detached.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;btn&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // If el is removed later ‚Üí listener still references it</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>‚úÖ Solution:</strong><br> Remove listeners when components unmount or elements are deleted:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleClick);</span></span></code></pre></div><p>In React, use cleanup in <code>useEffect()</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;resize&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, onResize);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;resize&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, onResize);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre></div><hr><h3 id="_2-unintended-global-variables" tabindex="-1">2. Unintended Global Variables <a class="header-anchor" href="#_2-unintended-global-variables" aria-label="Permalink to ‚Äú2. Unintended Global Variables‚Äù">‚Äã</a></h3><p>Omitting <code>let</code>, <code>const</code>, or <code>var</code> creates a property on the global object (<code>window</code>), which persists until the page reloads.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  leakedVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;oops&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// becomes window.leakedVar</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>‚úÖ Solution:</strong><br> Always use strict mode (<code>&#39;use strict&#39;</code>) and declare variables explicitly.</p><hr><h3 id="_3-closures-holding-references" tabindex="-1">3. Closures Holding References <a class="header-anchor" href="#_3-closures-holding-references" aria-label="Permalink to ‚Äú3. Closures Holding References‚Äù">‚Äã</a></h3><p>Inner functions capture outer variables ‚Äî if those variables reference large data, they stay in memory.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bigArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bigArray[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// closure keeps \`bigArray\` alive</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> leak</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p><strong>‚úÖ Solution:</strong><br> Avoid keeping large data in closures unless necessary.<br> Nullify or reassign references when no longer needed.</p><hr><h3 id="_4-detached-dom-nodes" tabindex="-1">4. Detached DOM Nodes <a class="header-anchor" href="#_4-detached-dom-nodes" aria-label="Permalink to ‚Äú4. Detached DOM Nodes‚Äù">‚Äã</a></h3><p>When DOM nodes are removed from the document but still referenced by JS variables or listeners.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// removed from DOM</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Still in memory because \`node\` references it</span></span></code></pre></div><p><strong>‚úÖ Solution:</strong><br> Set <code>node = null</code> after removal if it‚Äôs no longer needed.</p><hr><h3 id="_5-timers-and-intervals" tabindex="-1">5. Timers and Intervals <a class="header-anchor" href="#_5-timers-and-intervals" aria-label="Permalink to ‚Äú5. Timers and Intervals‚Äù">‚Äã</a></h3><p><code>setInterval()</code> and <code>setTimeout()</code> keep references to their callbacks, which may capture state or DOM references.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).innerText);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><strong>‚úÖ Solution:</strong><br> Always clear timers:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(doWork, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span></code></pre></div><p>Clean up intervals when components unmount (React <code>useEffect</code> cleanup).</p><hr><h3 id="_6-caching-gone-wrong" tabindex="-1">6. Caching Gone Wrong <a class="header-anchor" href="#_6-caching-gone-wrong" aria-label="Permalink to ‚Äú6. Caching Gone Wrong‚Äù">‚Äã</a></h3><p>Storing large data in memory caches (like Redux, Context, or custom JS objects) without eviction logic.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addToCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cache[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// grows indefinitely</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>‚úÖ Solution:</strong><br> Use weak maps/sets for automatic GC on key objects:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Implement cache limits or LRU (Least Recently Used) eviction.</p><hr><h3 id="_7-third-party-libraries-or-listeners" tabindex="-1">7. Third-Party Libraries or Listeners <a class="header-anchor" href="#_7-third-party-libraries-or-listeners" aria-label="Permalink to ‚Äú7. Third-Party Libraries or Listeners‚Äù">‚Äã</a></h3><p>Some libraries (especially older DOM manipulation ones) attach global listeners or store references internally.</p><p><strong>‚úÖ Solution:</strong><br> Check library docs for cleanup methods (e.g., <code>destroy()</code>, <code>dispose()</code>).<br> Wrap them inside lifecycle hooks for proper teardown.</p><hr><h3 id="_8-over-retained-react-state" tabindex="-1">8. Over-retained React State <a class="header-anchor" href="#_8-over-retained-react-state" aria-label="Permalink to ‚Äú8. Over-retained React State‚Äù">‚Äã</a></h3><p>State or refs holding large data (arrays, objects) that persist across re-renders or pages.</p><p><strong>‚úÖ Solution:</strong><br> Reset component state when unmounted or when route changes.<br> Don‚Äôt store heavy data directly in React state ‚Äî use external store or cache that can be cleared.</p><hr><h3 id="_9-large-in-memory-data-structures" tabindex="-1">9. Large In-Memory Data Structures <a class="header-anchor" href="#_9-large-in-memory-data-structures" aria-label="Permalink to ‚Äú9. Large In-Memory Data Structures‚Äù">‚Äã</a></h3><p>Example: keeping all fetched API results in arrays/lists without pruning.<br> Especially common in data-heavy apps (dashboards, grids).</p><p><strong>‚úÖ Solution:</strong><br> Paginate data.<br> Keep only visible/active portions in memory (e.g., virtualization with <code>react-window</code>).</p><hr><h2 id="üß∞-how-to-detect-and-diagnose-memory-leaks" tabindex="-1">üß∞ How to Detect and Diagnose Memory Leaks <a class="header-anchor" href="#üß∞-how-to-detect-and-diagnose-memory-leaks" aria-label="Permalink to ‚Äúüß∞ How to Detect and Diagnose Memory Leaks‚Äù">‚Äã</a></h2><ol><li><p><strong>Chrome DevTools ‚Üí Performance &amp; Memory Tabs</strong></p><ul><li>Use Performance ‚Üí record, look for steady heap growth.</li><li>Use Memory ‚Üí ‚ÄúHeap snapshot‚Äù or ‚ÄúAllocation instrumentation on timeline.‚Äù</li></ul></li><li><p><strong>Identify Detached DOM Elements</strong></p><ul><li>In Memory tab, filter by ‚ÄúDetached HTML elements‚Äù to see uncollected nodes.</li></ul></li><li><p><strong>Performance Profilers</strong></p><ul><li>Tools: Chrome DevTools, Lighthouse Performance, Sentry Performance, React Profiler</li></ul></li></ol><hr><h2 id="‚úÖ-summary-table" tabindex="-1">‚úÖ Summary Table <a class="header-anchor" href="#‚úÖ-summary-table" aria-label="Permalink to ‚Äú‚úÖ Summary Table‚Äù">‚Äã</a></h2><table tabindex="0"><thead><tr><th>Problem Source</th><th>Why It Leaks</th><th>How to Fix</th></tr></thead><tbody><tr><td>Event listeners</td><td>Object references persist</td><td>Remove listeners on cleanup</td></tr><tr><td>Global variables</td><td>Persistent global scope</td><td>Use let/const + strict mode</td></tr><tr><td>Closures</td><td>Capture large references</td><td>Nullify or avoid large captures</td></tr><tr><td>Detached DOM nodes</td><td>Referenced after removal</td><td>Remove references manually</td></tr><tr><td>Timers/Intervals</td><td>Keep references alive</td><td>Clear on unmount</td></tr><tr><td>Caches</td><td>Unbounded memory growth</td><td>WeakMaps / eviction logic</td></tr><tr><td>3rd-party libs</td><td>Internal references</td><td>Call .destroy() / .dispose()</td></tr><tr><td>React state</td><td>Persisting large objects</td><td>Reset on unmount</td></tr><tr><td>Large data</td><td>No pruning/pagination</td><td>Paginate or virtualize data</td></tr></tbody></table><hr><p><strong>üß† Rule of thumb:</strong><br> Memory leaks happen when you keep unintentional references to things that should‚Äôve been forgotten.<br> Always clean up listeners, timers, closures, and caches when the component or feature is no longer in use.</p>`,65)])])}const g=i(n,[["render",r]]);export{c as __pageData,g as default};
