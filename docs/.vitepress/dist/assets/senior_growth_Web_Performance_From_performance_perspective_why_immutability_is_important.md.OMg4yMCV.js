import{_ as e,c as s,o as a,af as t}from"./chunks/framework.C3eVOF8n.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/Web_Performance/From_performance_perspective_why_immutability_is_important.md","filePath":"senior_growth/Web_Performance/From_performance_perspective_why_immutability_is_important.md"}'),n={name:"senior_growth/Web_Performance/From_performance_perspective_why_immutability_is_important.md"};function r(l,i,h,p,d,o){return a(),s("div",null,[...i[0]||(i[0]=[t(`<h3 id="from-a-performance-perspective-why-is-immutability-important" tabindex="-1">From a performance perspective, why is immutability important? <a class="header-anchor" href="#from-a-performance-perspective-why-is-immutability-important" aria-label="Permalink to â€œFrom a performance perspective, why is immutability important?â€">â€‹</a></h3><p><strong>Immutability</strong> means that once a data structure is created, it cannot be changed.<br> Any &quot;change&quot; creates a <strong>new copy</strong> with modifications, leaving the original unchanged.</p><p>While it might seem slower at first, immutability is a <strong>major performance enabler</strong> in modern frontend frameworks (especially React, Redux, and functional JS patterns) â€” because it makes <strong>change detection</strong>, <strong>memoization</strong>, and <strong>state management</strong> much more efficient and predictable.</p><hr><h2 id="âš™ï¸-1-efficient-change-detection" tabindex="-1">âš™ï¸ 1. <strong>Efficient Change Detection</strong> <a class="header-anchor" href="#âš™ï¸-1-efficient-change-detection" aria-label="Permalink to â€œâš™ï¸ 1. Efficient Change Detectionâ€">â€‹</a></h2><p>Frameworks like <strong>React</strong> and <strong>Redux</strong> rely heavily on <em>reference equality</em> (<code>===</code>) to detect changes.</p><h3 id="ğŸ”¹-mutable-case-problematic" tabindex="-1">ğŸ”¹ Mutable case (problematic) <a class="header-anchor" href="#ğŸ”¹-mutable-case-problematic" aria-label="Permalink to â€œğŸ”¹ Mutable case (problematic)â€">â€‹</a></h3><p>If you mutate an object directly, React can&#39;t know something changed without deep comparison:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.user.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Lili&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// âŒ Mutating</span></span></code></pre></div><p>// React would have to deep-compare every field to detect this change</p><h3 id="ğŸ”¹-immutable-case-efficient" tabindex="-1">ğŸ”¹ Immutable case (efficient) <a class="header-anchor" href="#ğŸ”¹-immutable-case-efficient" aria-label="Permalink to â€œğŸ”¹ Immutable case (efficient)â€">â€‹</a></h3><p>If you return a new object, React can detect a change by shallow comparison:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prev,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  user: { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prev.user, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Lili&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// âœ… New reference</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}));</span></span></code></pre></div><p>â†’ Now <code>prev.user !== newState.user</code>, so React immediately knows that part of the UI should re-render.</p><p>Result:<br> Shallow comparisons (<code>===</code>) are O(1) instead of deep comparisons (O(n)).</p><hr><h2 id="âš¡-2-avoid-unnecessary-re-renders" tabindex="-1">âš¡ 2. <strong>Avoid Unnecessary Re-renders</strong> <a class="header-anchor" href="#âš¡-2-avoid-unnecessary-re-renders" aria-label="Permalink to â€œâš¡ 2. Avoid Unnecessary Re-rendersâ€">â€‹</a></h2><p>Immutability enables pure components and memoization.</p><ul><li><p><strong>With mutable state:</strong><br> Changes may not be detected correctly.<br> Components can re-render unnecessarily or fail to update.</p></li><li><p><strong>With immutable state:</strong><br> Libraries like <code>React.memo()</code> or <code>useMemo()</code> can skip re-renders safely.</p></li></ul><p>Example:</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MemoList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">items</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Only re-renders if &#39;items&#39; reference changes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{i}&gt;{i}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>If you mutate <code>items</code> directly, React can&#39;t detect the change efficiently.<br> If you replace <code>items</code> with a new array, React can skip re-renders when the reference hasn&#39;t changed.</p><p>âœ… Performance gain:<br> Fewer wasted renders, smoother UI, and better resource usage.</p><p>Example:</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">items</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Rendered&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{i}&gt;{i}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>// If <code>items</code> changes immutably â†’ new ref â†’ re-render only when needed<br> âœ… Performance gain: fewer wasted renders â†’ smoother UI.</p><hr><h2 id="ğŸ§ -3-predictable-state-transitions" tabindex="-1">ğŸ§  3. <strong>Predictable State Transitions</strong> <a class="header-anchor" href="#ğŸ§ -3-predictable-state-transitions" aria-label="Permalink to â€œğŸ§  3. Predictable State Transitionsâ€">â€‹</a></h2><p>Immutable updates create a history of states.<br> This improves debugging, undo/redo functionality, and time-travel debugging (as in Redux DevTools).</p><p>Because each state snapshot is distinct:</p><ul><li>You can easily revert, compare, or test.</li><li>You avoid hidden mutations that cause difficult-to-track bugs.</li></ul><p>ğŸ§© In performance terms, predictable updates reduce â€œmystery reflowsâ€ and â€œzombie rendersâ€ caused by unexpected DOM state changes.</p><hr><h2 id="ğŸ§®-4-enables-structural-sharing-memory-efficient" tabindex="-1">ğŸ§® 4. <strong>Enables Structural Sharing (Memory Efficient)</strong> <a class="header-anchor" href="#ğŸ§®-4-enables-structural-sharing-memory-efficient" aria-label="Permalink to â€œğŸ§® 4. Enables Structural Sharing (Memory Efficient)â€">â€‹</a></h2><p>Libraries like Immer or Immutable.js use structural sharing:</p><ul><li>Only the changed parts of an object are copied.</li><li>Unchanged branches are reused via references.</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldState, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">draft</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  draft.user.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Lili&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>Even though immutability creates a â€œnewâ€ object, under the hood:</p><ul><li>Only the changed nodes are new; everything else reuses the same memory references.</li></ul><p>âœ… So immutability doesnâ€™t mean full duplication â€” itâ€™s optimized for speed and memory.</p><hr><h2 id="ğŸš¦-5-prevents-accidental-state-corruption" tabindex="-1">ğŸš¦ 5. <strong>Prevents Accidental State Corruption</strong> <a class="header-anchor" href="#ğŸš¦-5-prevents-accidental-state-corruption" aria-label="Permalink to â€œğŸš¦ 5. Prevents Accidental State Corruptionâ€">â€‹</a></h2><p>Mutable objects shared across components can cause side effects:</p><ul><li>Two components modify the same reference â†’ unpredictable behavior.</li><li>Re-renders caused by mutated global state.</li></ul><p>Immutability isolates data â†’ ensures deterministic rendering.<br> Stable state = fewer reflows, fewer unnecessary paints, more predictable performance.</p><hr><h2 id="âš ï¸-performance-trade-offs" tabindex="-1">âš ï¸ Performance Trade-offs <a class="header-anchor" href="#âš ï¸-performance-trade-offs" aria-label="Permalink to â€œâš ï¸ Performance Trade-offsâ€">â€‹</a></h2><table tabindex="0"><thead><tr><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td>Faster change detection</td><td>Slightly more GC work (new objects)</td></tr><tr><td>Safe memoization</td><td>Extra memory for new structures</td></tr><tr><td>Predictable re-renders</td><td>Requires discipline or helper libraries (e.g. Immer)</td></tr></tbody></table><p>However, due to structural sharing and modern GC optimizations, the cost is minimal compared to the stability and rendering efficiency gained.</p><hr><h2 id="ğŸ§©-summary" tabindex="-1">ğŸ§© Summary <a class="header-anchor" href="#ğŸ§©-summary" aria-label="Permalink to â€œğŸ§© Summaryâ€">â€‹</a></h2><table tabindex="0"><thead><tr><th>Benefit</th><th>Description</th><th>Performance Impact</th></tr></thead><tbody><tr><td>Fast change detection</td><td>Shallow equality replaces deep diffing</td><td>ğŸ”¥ Major</td></tr><tr><td>Fewer re-renders</td><td>Works well with React.memo/useMemo</td><td>âš¡ High</td></tr><tr><td>Predictable state updates</td><td>Avoids hidden side effects</td><td>âœ… Stable</td></tr><tr><td>Structural sharing</td><td>Efficient memory usage</td><td>ğŸ§  Optimized</td></tr><tr><td>Safe concurrency</td><td>Prevents race conditions in async updates</td><td>ğŸ›¡ï¸ Reliable</td></tr></tbody></table><hr><h2 id="âœ…-key-takeaway" tabindex="-1">âœ… Key Takeaway <a class="header-anchor" href="#âœ…-key-takeaway" aria-label="Permalink to â€œâœ… Key Takeawayâ€">â€‹</a></h2><p>ğŸ’¡ Immutability isnâ€™t about making code â€œfunctionalâ€ â€”<br> itâ€™s about making change detection cheap, rendering predictable, and performance consistent.</p><p>In short:</p><p>Immutability trades small memory costs for huge gains in rendering efficiency, debugging clarity, and long-term app stability.</p>`,57)])])}const g=e(n,[["render",r]]);export{c as __pageData,g as default};
