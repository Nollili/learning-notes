import{_ as i,c as t,o as n,af as a}from"./chunks/framework.C3eVOF8n.js";const d=JSON.parse('{"title":"What are the common pitfalls when applying a design pattern?```markdown","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/Coding principles_patterns_conventions/What are the common pitfalls when applying a design pattern.md","filePath":"senior_growth/Coding principles_patterns_conventions/What are the common pitfalls when applying a design pattern.md"}'),r={name:"senior_growth/Coding principles_patterns_conventions/What are the common pitfalls when applying a design pattern.md"};function o(s,e,l,p,c,g){return n(),t("div",null,[...e[0]||(e[0]=[a('<h1 id="what-are-the-common-pitfalls-when-applying-a-design-pattern-markdown" tabindex="-1">What are the common pitfalls when applying a design pattern?```markdown <a class="header-anchor" href="#what-are-the-common-pitfalls-when-applying-a-design-pattern-markdown" aria-label="Permalink to ‚ÄúWhat are the common pitfalls when applying a design pattern?```markdown‚Äù">‚Äã</a></h1><h1 id="‚ö†Ô∏è-common-pitfalls-when-applying-design-patterns-in-javascript" tabindex="-1">‚ö†Ô∏è Common Pitfalls When Applying Design Patterns in JavaScript <a class="header-anchor" href="#‚ö†Ô∏è-common-pitfalls-when-applying-design-patterns-in-javascript" aria-label="Permalink to ‚Äú‚ö†Ô∏è Common Pitfalls When Applying Design Patterns in JavaScript‚Äù">‚Äã</a></h1><p>Design patterns are powerful tools, but <strong>misusing them can introduce complexity, reduce maintainability, or hurt performance</strong>. Here‚Äôs a detailed overview of common pitfalls to avoid.</p><hr><h2 id="_1Ô∏è‚É£-overengineering-premature-optimization" tabindex="-1">1Ô∏è‚É£ Overengineering / Premature Optimization <a class="header-anchor" href="#_1Ô∏è‚É£-overengineering-premature-optimization" aria-label="Permalink to ‚Äú1Ô∏è‚É£ Overengineering / Premature Optimization‚Äù">‚Äã</a></h2><ul><li>Applying patterns <strong>before there‚Äôs a real need</strong>.</li><li>Example: Using Observer or Decorator for a small component that doesn‚Äôt require dynamic behavior.</li><li><strong>Consequence:</strong> Extra abstraction makes code harder to read, maintain, and debug.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Only introduce a pattern when there‚Äôs a clear requirement or recurring problem.</p></blockquote><hr><h2 id="_2Ô∏è‚É£-misusing-inheritance-instead-of-composition" tabindex="-1">2Ô∏è‚É£ Misusing Inheritance Instead of Composition <a class="header-anchor" href="#_2Ô∏è‚É£-misusing-inheritance-instead-of-composition" aria-label="Permalink to ‚Äú2Ô∏è‚É£ Misusing Inheritance Instead of Composition‚Äù">‚Äã</a></h2><ul><li>Over-reliance on class hierarchies can lead to: <ul><li>Deep, rigid inheritance trees</li><li>Fragile base classes where changes propagate unexpectedly</li></ul></li><li>Example: A ‚ÄúBird‚Äù class with subclasses like ‚ÄúPenguin‚Äù violating LSP (cannot fly).</li></ul><p><strong>Tip:</strong></p><blockquote><p>Prefer <strong>composition over inheritance</strong> for flexibility and decoupling.</p></blockquote><hr><h2 id="_3Ô∏è‚É£-ignoring-single-responsibility-principle" tabindex="-1">3Ô∏è‚É£ Ignoring Single Responsibility Principle <a class="header-anchor" href="#_3Ô∏è‚É£-ignoring-single-responsibility-principle" aria-label="Permalink to ‚Äú3Ô∏è‚É£ Ignoring Single Responsibility Principle‚Äù">‚Äã</a></h2><ul><li>Using a pattern but packing too much functionality into a single class/object.</li><li>Example: A Singleton that handles logging, caching, and API requests all in one.</li><li><strong>Consequence:</strong> Difficult to test, extend, or replace.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Keep components <strong>focused and modular</strong>. One pattern per responsibility.</p></blockquote><hr><h2 id="_4Ô∏è‚É£-overusing-hocs-or-decorators-in-react" tabindex="-1">4Ô∏è‚É£ Overusing HOCs or Decorators in React <a class="header-anchor" href="#_4Ô∏è‚É£-overusing-hocs-or-decorators-in-react" aria-label="Permalink to ‚Äú4Ô∏è‚É£ Overusing HOCs or Decorators in React‚Äù">‚Äã</a></h2><ul><li>Excessive nesting of HOCs can lead to: <ul><li>‚ÄúWrapper hell‚Äù</li><li>Hard-to-debug component trees</li></ul></li><li>Example: <code>&lt;withAuth(withLogger(withTheme(MyComponent))) /&gt;</code></li></ul><p><strong>Tip:</strong></p><blockquote><p>Use <strong>hooks</strong> and composition to simplify behavior reuse instead of deep HOC chains.</p></blockquote><hr><h2 id="_5Ô∏è‚É£-breaking-liskov-substitution-principle-lsp" tabindex="-1">5Ô∏è‚É£ Breaking Liskov Substitution Principle (LSP) <a class="header-anchor" href="#_5Ô∏è‚É£-breaking-liskov-substitution-principle-lsp" aria-label="Permalink to ‚Äú5Ô∏è‚É£ Breaking Liskov Substitution Principle (LSP)‚Äù">‚Äã</a></h2><ul><li>Creating subclasses that <strong>cannot fully replace their base classes</strong>.</li><li>Example: Subclass overriding method in a way that throws errors for valid base-class calls.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Ensure <strong>subtypes respect the parent interface and behavior</strong>.</p></blockquote><hr><h2 id="_6Ô∏è‚É£-overcomplicating-with-patterns-for-simple-problems" tabindex="-1">6Ô∏è‚É£ Overcomplicating with Patterns for Simple Problems <a class="header-anchor" href="#_6Ô∏è‚É£-overcomplicating-with-patterns-for-simple-problems" aria-label="Permalink to ‚Äú6Ô∏è‚É£ Overcomplicating with Patterns for Simple Problems‚Äù">‚Äã</a></h2><ul><li>Applying patterns like Strategy, Factory, or Observer for trivial functionality.</li><li><strong>Consequence:</strong> Code becomes harder to understand and maintain.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Evaluate <strong>simplicity first</strong>, then introduce patterns gradually.</p></blockquote><hr><h2 id="_7Ô∏è‚É£-ignoring-immutability-with-state-patterns" tabindex="-1">7Ô∏è‚É£ Ignoring Immutability with State Patterns <a class="header-anchor" href="#_7Ô∏è‚É£-ignoring-immutability-with-state-patterns" aria-label="Permalink to ‚Äú7Ô∏è‚É£ Ignoring Immutability with State Patterns‚Äù">‚Äã</a></h2><ul><li>When combining patterns with <strong>shared mutable state</strong>, it can lead to: <ul><li>Unexpected side effects</li><li>Hard-to-trace bugs in reactive apps (React, Redux)</li></ul></li><li>Example: A Decorator modifying an object‚Äôs state directly instead of returning a new object.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Prefer <strong>immutable updates</strong> to avoid subtle state issues.</p></blockquote><hr><h2 id="_8Ô∏è‚É£-mixing-multiple-patterns-indiscriminately" tabindex="-1">8Ô∏è‚É£ Mixing Multiple Patterns Indiscriminately <a class="header-anchor" href="#_8Ô∏è‚É£-mixing-multiple-patterns-indiscriminately" aria-label="Permalink to ‚Äú8Ô∏è‚É£ Mixing Multiple Patterns Indiscriminately‚Äù">‚Äã</a></h2><ul><li>Applying too many patterns together without clear boundaries.</li><li>Example: Singleton + Factory + Observer in one module without clear separation.</li><li><strong>Consequence:</strong> Increases cognitive load, debugging difficulty, and coupling.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Keep patterns <strong>isolated and purposeful</strong>. Use one pattern per concern.</p></blockquote><hr><h2 id="_9Ô∏è‚É£-performance-pitfalls" tabindex="-1">9Ô∏è‚É£ Performance Pitfalls <a class="header-anchor" href="#_9Ô∏è‚É£-performance-pitfalls" aria-label="Permalink to ‚Äú9Ô∏è‚É£ Performance Pitfalls‚Äù">‚Äã</a></h2><ul><li>Some patterns introduce <strong>extra objects, wrappers, or function calls</strong>.</li><li>Example: <ul><li>Deeply nested Decorators or HOCs in React</li><li>Observer with many subscribers firing frequently</li></ul></li><li><strong>Consequence:</strong> Can reduce performance, especially in UI rendering.</li></ul><p><strong>Tip:</strong></p><blockquote><p>Use <strong>memoization, throttling, or selective subscriptions</strong> where necessary.</p></blockquote><hr><h2 id="_10Ô∏è‚É£-not-considering-testing-implications" tabindex="-1">10Ô∏è‚É£ Not Considering Testing Implications <a class="header-anchor" href="#_10Ô∏è‚É£-not-considering-testing-implications" aria-label="Permalink to ‚Äú10Ô∏è‚É£ Not Considering Testing Implications‚Äù">‚Äã</a></h2><ul><li>Patterns that introduce hidden state or complex interactions can make testing harder.</li><li>Example: Singleton storing global state across tests.</li><li><strong>Tip:</strong></li></ul><blockquote><p>Always design patterns with <strong>testability</strong> in mind:</p></blockquote><ul><li>Inject dependencies</li><li>Avoid global mutable state</li><li>Favor pure functions for easier unit testing</li></ul><hr><h3 id="‚úÖ-key-takeaways" tabindex="-1">‚úÖ Key Takeaways <a class="header-anchor" href="#‚úÖ-key-takeaways" aria-label="Permalink to ‚Äú‚úÖ Key Takeaways‚Äù">‚Äã</a></h3><ol><li>Patterns are <strong>tools, not rules</strong>; apply them only when necessary.</li><li><strong>Keep it simple</strong> ‚Äî don‚Äôt overcomplicate solutions.</li><li><strong>Focus on readability, maintainability, and testability.</strong></li><li>Use <strong>composition, immutability, and modular design</strong> to avoid pitfalls.</li><li>Always evaluate <strong>performance and side effects</strong>, especially in reactive apps like React.</li></ol><blockquote><p>üí° Senior Tip:<br> A true sign of mastery is knowing <strong>when NOT to use a pattern</strong>.</p></blockquote><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span></span></span></code></pre></div>',58)])])}const m=i(r,[["render",o]]);export{d as __pageData,m as default};
