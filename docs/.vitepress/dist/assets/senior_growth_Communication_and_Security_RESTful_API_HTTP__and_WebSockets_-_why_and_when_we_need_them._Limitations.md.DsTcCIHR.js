import{_ as e,c as a,o as s,af as i}from"./chunks/framework.C3eVOF8n.js";const k=JSON.parse('{"title":"RESTful API(HTTP) and WebSockets - why and when we need them. Limitations?","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/Communication_and_Security/RESTful_API_HTTP__and_WebSockets_-_why_and_when_we_need_them._Limitations.md","filePath":"senior_growth/Communication_and_Security/RESTful_API_HTTP__and_WebSockets_-_why_and_when_we_need_them._Limitations.md"}'),n={name:"senior_growth/Communication_and_Security/RESTful_API_HTTP__and_WebSockets_-_why_and_when_we_need_them._Limitations.md"};function r(o,t,d,l,h,c){return s(),a("div",null,[...t[0]||(t[0]=[i(`<h1 id="restful-api-http-and-websockets-why-and-when-we-need-them-limitations" tabindex="-1">RESTful API(HTTP) and WebSockets - why and when we need them. Limitations? <a class="header-anchor" href="#restful-api-http-and-websockets-why-and-when-we-need-them-limitations" aria-label="Permalink to â€œRESTful API(HTTP) and WebSockets - why and when we need them. Limitations?â€">â€‹</a></h1><h1 id="ğŸŒ-restful-apis-vs-websockets-â€”-when-and-why-to-use-each" tabindex="-1">ğŸŒ RESTful APIs vs WebSockets â€” When and Why to Use Each <a class="header-anchor" href="#ğŸŒ-restful-apis-vs-websockets-â€”-when-and-why-to-use-each" aria-label="Permalink to â€œğŸŒ RESTful APIs vs WebSockets â€” When and Why to Use Eachâ€">â€‹</a></h1><p>Understanding the trade-offs between <strong>RESTful APIs</strong> and <strong>WebSockets</strong> is key to designing scalable, performant, and maintainable front-end architectures.</p><hr><h2 id="âš™ï¸-restful-api-http" tabindex="-1">âš™ï¸ RESTful API (HTTP) <a class="header-anchor" href="#âš™ï¸-restful-api-http" aria-label="Permalink to â€œâš™ï¸ RESTful API (HTTP)â€">â€‹</a></h2><h3 id="ğŸ”‘-what-it-is" tabindex="-1">ğŸ”‘ What It Is <a class="header-anchor" href="#ğŸ”‘-what-it-is" aria-label="Permalink to â€œğŸ”‘ What It Isâ€">â€‹</a></h3><ul><li><strong>REST (Representational State Transfer)</strong> is an <strong>architectural style</strong> built on top of <strong>HTTP</strong>.</li><li>Each request is <strong>stateless</strong> â€” all info needed to process it is included in the request.</li><li>Communication pattern: <strong>request â†’ response</strong>.</li></ul><h3 id="ğŸ§©-core-characteristics" tabindex="-1">ğŸ§© Core Characteristics <a class="header-anchor" href="#ğŸ§©-core-characteristics" aria-label="Permalink to â€œğŸ§© Core Characteristicsâ€">â€‹</a></h3><table tabindex="0"><thead><tr><th>Principle</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>Stateless</strong></td><td>Server doesnâ€™t keep client session state.</td></tr><tr><td><strong>Resource-oriented</strong></td><td>URLs represent resources (e.g., <code>/users/123</code>).</td></tr><tr><td><strong>CRUD operations</strong></td><td>Commonly uses <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>.</td></tr><tr><td><strong>Cacheable</strong></td><td>Responses can be cached via HTTP headers.</td></tr><tr><td><strong>Uniform interface</strong></td><td>Standard methods and response formats (usually JSON).</td></tr></tbody></table><h3 id="âœ…-advantages" tabindex="-1">âœ… Advantages <a class="header-anchor" href="#âœ…-advantages" aria-label="Permalink to â€œâœ… Advantagesâ€">â€‹</a></h3><ul><li>Simple and widely supported (HTTP everywhere).</li><li>Scales easily via stateless design.</li><li>Works with CDNs and caching layers.</li><li>Easy to test and debug.</li><li>Ideal for traditional CRUD operations and static data fetching.</li></ul><h3 id="âš ï¸-limitations" tabindex="-1">âš ï¸ Limitations <a class="header-anchor" href="#âš ï¸-limitations" aria-label="Permalink to â€œâš ï¸ Limitationsâ€">â€‹</a></h3><ul><li><strong>One-way communication</strong>: client must poll to get updates.</li><li><strong>Latency from polling</strong>: repeated HTTP requests.</li><li>Inefficient for <strong>real-time data</strong> (e.g., chat, notifications, dashboards).</li><li>Overhead from headers in every request.</li><li>No built-in way to maintain persistent connection.</li></ul><h3 id="ğŸ§ -best-use-cases" tabindex="-1">ğŸ§  Best Use Cases <a class="header-anchor" href="#ğŸ§ -best-use-cases" aria-label="Permalink to â€œğŸ§  Best Use Casesâ€">â€‹</a></h3><ul><li>Standard web apps or APIs (CRUD operations).</li><li>Static or infrequently changing data.</li><li>Microservices APIs.</li><li>Mobile and web clients that fetch resources on demand.</li></ul><hr><h2 id="ğŸ”„-websockets" tabindex="-1">ğŸ”„ WebSockets <a class="header-anchor" href="#ğŸ”„-websockets" aria-label="Permalink to â€œğŸ”„ WebSocketsâ€">â€‹</a></h2><h3 id="ğŸ”‘-what-it-is-1" tabindex="-1">ğŸ”‘ What It Is <a class="header-anchor" href="#ğŸ”‘-what-it-is-1" aria-label="Permalink to â€œğŸ”‘ What It Isâ€">â€‹</a></h3><ul><li>A <strong>full-duplex, persistent</strong> communication channel over a <strong>single TCP connection</strong>.</li><li>Allows <strong>real-time, bi-directional</strong> communication between client and server.</li><li>Protocol: <code>ws://</code> or <code>wss://</code> (secure).</li></ul><h3 id="ğŸ”§-how-it-works" tabindex="-1">ğŸ”§ How It Works <a class="header-anchor" href="#ğŸ”§-how-it-works" aria-label="Permalink to â€œğŸ”§ How It Worksâ€">â€‹</a></h3><ol><li>Starts as an <strong>HTTP handshake</strong> (request with <code>Upgrade: websocket</code> header).</li><li>Once upgraded, both client and server can send data anytime â€” no polling.</li><li>Connection remains open until closed by either side.</li></ol><h3 id="âœ…-advantages-1" tabindex="-1">âœ… Advantages <a class="header-anchor" href="#âœ…-advantages-1" aria-label="Permalink to â€œâœ… Advantagesâ€">â€‹</a></h3><ul><li><strong>Low latency</strong> â†’ instant data exchange.</li><li><strong>Bi-directional</strong> â†’ both sides can send messages freely.</li><li><strong>Efficient</strong> â†’ no repeated HTTP headers.</li><li>Ideal for <strong>real-time updates</strong> and event-driven systems.</li><li>Works well with streaming or continuous feeds.</li></ul><h3 id="âš ï¸-limitations-1" tabindex="-1">âš ï¸ Limitations <a class="header-anchor" href="#âš ï¸-limitations-1" aria-label="Permalink to â€œâš ï¸ Limitationsâ€">â€‹</a></h3><ul><li><strong>Stateful connection</strong> â†’ harder to scale horizontally.</li><li>Not cacheable via CDNs.</li><li>Requires a WebSocket-capable backend and proxy setup.</li><li>Harder to debug and secure than HTTP.</li><li>Load balancers, firewalls, and proxies sometimes block or break persistent connections.</li></ul><h3 id="ğŸ§ -best-use-cases-1" tabindex="-1">ğŸ§  Best Use Cases <a class="header-anchor" href="#ğŸ§ -best-use-cases-1" aria-label="Permalink to â€œğŸ§  Best Use Casesâ€">â€‹</a></h3><ul><li>Real-time apps: <ul><li>Chat/messaging systems</li><li>Live dashboards / financial tickers</li><li>Multiplayer games</li><li>Collaborative editors</li><li>Real-time notifications</li></ul></li><li>When you need instant data push from server to client.</li></ul><hr><h2 id="ğŸ§©-rest-vs-websocket-â€”-comparison-table" tabindex="-1">ğŸ§© REST vs WebSocket â€” Comparison Table <a class="header-anchor" href="#ğŸ§©-rest-vs-websocket-â€”-comparison-table" aria-label="Permalink to â€œğŸ§© REST vs WebSocket â€” Comparison Tableâ€">â€‹</a></h2><table tabindex="0"><thead><tr><th>Feature</th><th>RESTful API</th><th>WebSocket</th></tr></thead><tbody><tr><td><strong>Connection</strong></td><td>Short-lived (per request)</td><td>Persistent (kept open)</td></tr><tr><td><strong>Communication Type</strong></td><td>Requestâ€“Response</td><td>Full-duplex (bi-directional)</td></tr><tr><td><strong>Transport Protocol</strong></td><td>HTTP/HTTPS</td><td>WS/WSS (TCP)</td></tr><tr><td><strong>State</strong></td><td>Stateless</td><td>Stateful</td></tr><tr><td><strong>Data Transfer</strong></td><td>JSON or XML over HTTP</td><td>Custom format (often JSON, binary, or protobuf)</td></tr><tr><td><strong>Performance</strong></td><td>Higher overhead</td><td>Lower overhead</td></tr><tr><td><strong>Scalability</strong></td><td>Easier (stateless)</td><td>Harder (persistent connections)</td></tr><tr><td><strong>Caching</strong></td><td>Supported</td><td>Not supported</td></tr><tr><td><strong>Security</strong></td><td>Standard HTTPS/TLS</td><td>WSS (TLS-secured)</td></tr><tr><td><strong>Typical Use Cases</strong></td><td>CRUD APIs, forms, static data</td><td>Real-time apps, streaming, chat</td></tr></tbody></table><hr><h2 id="âš™ï¸-hybrid-approach-common-in-modern-apps" tabindex="-1">âš™ï¸ Hybrid Approach (Common in Modern Apps) <a class="header-anchor" href="#âš™ï¸-hybrid-approach-common-in-modern-apps" aria-label="Permalink to â€œâš™ï¸ Hybrid Approach (Common in Modern Apps)â€">â€‹</a></h2><p>Many modern architectures combine both:</p><table tabindex="0"><thead><tr><th>Layer</th><th>Protocol</th><th>Example</th></tr></thead><tbody><tr><td><strong>API layer</strong></td><td>REST / GraphQL over HTTP</td><td>CRUD, initial data fetch</td></tr><tr><td><strong>Real-time updates</strong></td><td>WebSocket / SSE</td><td>Live updates, notifications</td></tr><tr><td><strong>Fallback</strong></td><td>HTTP long-polling</td><td>Backup if WS not available</td></tr></tbody></table><p>Example:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Initial load via REST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/api/users/123&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Real-time updates via WebSocket</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;wss://api.example.com/updates&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateUI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data));</span></span></code></pre></div><hr><h2 id="ğŸ”’-security-considerations" tabindex="-1">ğŸ”’ Security Considerations <a class="header-anchor" href="#ğŸ”’-security-considerations" aria-label="Permalink to â€œğŸ”’ Security Considerationsâ€">â€‹</a></h2><table tabindex="0"><thead><tr><th>Risk</th><th>REST</th><th>WebSocket</th><th>Prevention</th></tr></thead><tbody><tr><td>Authentication</td><td>JWT, Cookies</td><td>Token in initial handshake</td><td>Use short-lived JWTs</td></tr><tr><td>CSRF</td><td>Possible</td><td>Less common</td><td>Use CSRF tokens</td></tr><tr><td>Data integrity</td><td>HTTPS</td><td>WSS</td><td>Enforce TLS</td></tr><tr><td>Rate limiting</td><td>Easy</td><td>Harder</td><td>Implement in backend gateway</td></tr><tr><td>Message injection</td><td>N/A</td><td>Possible</td><td>Validate all inbound messages</td></tr></tbody></table><hr><h2 id="ğŸ§ -summary" tabindex="-1">ğŸ§  Summary <a class="header-anchor" href="#ğŸ§ -summary" aria-label="Permalink to â€œğŸ§  Summaryâ€">â€‹</a></h2><table tabindex="0"><thead><tr><th>When To Use</th><th>Choose</th></tr></thead><tbody><tr><td>Simple CRUD, scalable APIs</td><td>âœ… <strong>REST</strong></td></tr><tr><td>Real-time interactions</td><td>âœ… <strong>WebSocket</strong></td></tr><tr><td>Combination of both (initial fetch + updates)</td><td>âœ… <strong>Hybrid</strong></td></tr></tbody></table><hr><p><strong>Key Takeaway:</strong></p><blockquote><p>REST is ideal for <strong>structured, scalable, and cacheable data exchange</strong>. WebSockets shine in <strong>low-latency, interactive, real-time</strong> applications. As a senior developer, understanding both â€” and when to combine them â€” is essential for building modern, efficient systems.</p></blockquote>`,45)])])}const g=e(n,[["render",r]]);export{k as __pageData,g as default};
