import{_ as e,c as i,o as a,af as t}from"./chunks/framework.C3eVOF8n.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/General ES6/Explain_asynchronousity_event_loop_in_JS_to_a_newc_177e8106c24d80a2ae55e9f5b8e91cf0.md","filePath":"senior_growth/General ES6/Explain_asynchronousity_event_loop_in_JS_to_a_newc_177e8106c24d80a2ae55e9f5b8e91cf0.md"}'),n={name:"senior_growth/General ES6/Explain_asynchronousity_event_loop_in_JS_to_a_newc_177e8106c24d80a2ae55e9f5b8e91cf0.md"};function o(l,s,h,r,c,p){return a(),i("div",null,[...s[0]||(s[0]=[t(`<h3 id="explain-asynchronousity-event-loop-in-js-to-a-newcomer" tabindex="-1">Explain asynchronousity/event loop in JS to a newcomer? <a class="header-anchor" href="#explain-asynchronousity-event-loop-in-js-to-a-newcomer" aria-label="Permalink to “Explain asynchronousity/event loop in JS to a newcomer?”">​</a></h3><h3 id="_1-what-is-asynchronousity" tabindex="-1">1. <strong>What is Asynchronousity?</strong> <a class="header-anchor" href="#_1-what-is-asynchronousity" aria-label="Permalink to “1. What is Asynchronousity?”">​</a></h3><ul><li>In JavaScript, asynchronousity allows you to execute tasks without blocking the main thread.</li><li>This means your code can do multiple things at the same time, like fetching data from the internet or waiting for a timer, while still being able to handle other tasks.</li></ul><p>Think of it like a restaurant:</p><ul><li>The chef (JavaScript) doesn’t stop cooking other dishes while waiting for your pizza (an asynchronous task) to bake in the oven.</li><li>When the pizza is ready, the oven (asynchronous event) notifies the chef, and the pizza is served.</li></ul><hr><h3 id="_2-the-event-loop-the-heart-of-async-in-js" tabindex="-1">2. <strong>The Event Loop: The Heart of Async in JS</strong> <a class="header-anchor" href="#_2-the-event-loop-the-heart-of-async-in-js" aria-label="Permalink to “2. The Event Loop: The Heart of Async in JS”">​</a></h3><p>JavaScript has a single-threaded runtime, meaning it can only do one thing at a time. So how does it handle asynchronous tasks? Enter the <strong>event loop</strong>.</p><h3 id="here-s-how-it-works" tabindex="-1">Here’s how it works: <a class="header-anchor" href="#here-s-how-it-works" aria-label="Permalink to “Here’s how it works:”">​</a></h3><ol><li><strong>Call Stack</strong>: <ul><li>Think of this as a &quot;to-do list&quot; for JavaScript. When a function is called, it gets added to the stack. When it&#39;s done, it’s removed.</li><li>Example: If you call <code>console.log(&quot;Hello&quot;)</code>, it goes onto the stack, runs, and gets removed.</li></ul></li><li><strong>Web APIs</strong>: <ul><li>When an async task is triggered (like <code>setTimeout</code>, <code>fetch</code>, or DOM events), JavaScript hands it off to the browser’s <strong>Web APIs</strong> or Node.js equivalent.</li><li>These APIs manage the task in the background (e.g., counting down a timer or fetching data).</li></ul></li><li><strong>Task Queue</strong>: <ul><li>When an async task finishes (e.g., the timer ends), its callback is placed in the <strong>task queue</strong> (or the microtask queue for Promises).</li><li>But it doesn’t run immediately—JavaScript first finishes everything in the <strong>call stack</strong>.</li></ul></li><li><strong>Event Loop</strong>: <ul><li>The event loop keeps checking: “Is the call stack empty?”</li><li>If yes, it picks the first task from the queue and puts it on the stack to be executed.</li></ul></li></ol><hr><h3 id="_3-example-in-action" tabindex="-1">3. <strong>Example in Action</strong> <a class="header-anchor" href="#_3-example-in-action" aria-label="Permalink to “3. Example in Action”">​</a></h3><p>Here’s a simple example:</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Async Task Finished!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;End&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="what-happens" tabindex="-1">What happens: <a class="header-anchor" href="#what-happens" aria-label="Permalink to “What happens:”">​</a></h3><ol><li><code>&quot;Start&quot;</code> is logged immediately (call stack).</li><li><code>setTimeout</code> is handed to the Web API to wait for 2 seconds.</li><li><code>&quot;End&quot;</code> is logged (call stack is empty).</li><li>After 2 seconds, the callback from <code>setTimeout</code> (<code>console.log(&quot;Async Task Finished!&quot;)</code>) moves to the queue and then to the stack, where it executes.</li></ol><p><strong>Output:</strong></p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Start</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">End</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Async Task Finished!</span></span></code></pre></div><hr><h3 id="_4-why-is-this-important" tabindex="-1">4. <strong>Why Is This Important?</strong> <a class="header-anchor" href="#_4-why-is-this-important" aria-label="Permalink to “4. Why Is This Important?”">​</a></h3><ul><li><strong>Responsiveness</strong>: The page stays responsive even if you’re waiting for data.</li><li><strong>Scalability</strong>: Helps you handle many tasks (like user interactions and network requests) efficiently.</li></ul>`,21)])])}const g=e(n,[["render",o]]);export{k as __pageData,g as default};
