import{_ as s,c as e,o as a,af as n}from"./chunks/framework.C3eVOF8n.js";const g=JSON.parse('{"title":"Do you still think BEM style is valid nowadays? Main benefits?","description":"","frontmatter":{},"headers":[],"relativePath":"senior_growth/CSS/Do_you_still_think_BEM_style_is_valid_nowadays_Main_benefits.md","filePath":"senior_growth/CSS/Do_you_still_think_BEM_style_is_valid_nowadays_Main_benefits.md"}'),l={name:"senior_growth/CSS/Do_you_still_think_BEM_style_is_valid_nowadays_Main_benefits.md"};function t(r,i,o,d,h,c){return a(),e("div",null,[...i[0]||(i[0]=[n(`<h1 id="do-you-still-think-bem-style-is-valid-nowadays-main-benefits" tabindex="-1">Do you still think BEM style is valid nowadays? Main benefits? <a class="header-anchor" href="#do-you-still-think-bem-style-is-valid-nowadays-main-benefits" aria-label="Permalink to ‚ÄúDo you still think BEM style is valid nowadays? Main benefits?‚Äù">‚Äã</a></h1><h2 id="üîπ-bem-block-element-modifier-in-modern-frontend" tabindex="-1">üîπ BEM (Block Element Modifier) in Modern Frontend <a class="header-anchor" href="#üîπ-bem-block-element-modifier-in-modern-frontend" aria-label="Permalink to ‚Äúüîπ BEM (Block Element Modifier) in Modern Frontend‚Äù">‚Äã</a></h2><p><strong>BEM</strong> is a CSS naming methodology that stands for:</p><ul><li><strong>Block</strong>: Independent, reusable component (<code>.button</code>)</li><li><strong>Element</strong>: Part of a block (<code>.button__icon</code>)</li><li><strong>Modifier</strong>: Variation or state (<code>.button--primary</code>)</li></ul><hr><h2 id="_1Ô∏è‚É£-is-bem-still-valid" tabindex="-1">1Ô∏è‚É£ Is BEM Still Valid? <a class="header-anchor" href="#_1Ô∏è‚É£-is-bem-still-valid" aria-label="Permalink to ‚Äú1Ô∏è‚É£ Is BEM Still Valid?‚Äù">‚Äã</a></h2><p>Yes. BEM remains relevant <strong>even with modern frontend frameworks</strong> like React, Vue, or Angular.</p><p>However, its usage has evolved:</p><ul><li><strong>CSS Modules / Scoped CSS</strong> reduce naming conflicts, making BEM less critical.</li><li><strong>CSS-in-JS / Tailwind CSS</strong> sometimes replaces the need for verbose class names.</li><li><strong>BEM still works well</strong> for large codebases or multi-developer teams where <strong>clear structure and readability</strong> is needed.</li></ul><hr><h2 id="_2Ô∏è‚É£-main-benefits-of-bem" tabindex="-1">2Ô∏è‚É£ Main Benefits of BEM <a class="header-anchor" href="#_2Ô∏è‚É£-main-benefits-of-bem" aria-label="Permalink to ‚Äú2Ô∏è‚É£ Main Benefits of BEM‚Äù">‚Äã</a></h2><h3 id="_2-1-readability-structure" tabindex="-1">2.1 Readability &amp; Structure <a class="header-anchor" href="#_2-1-readability-structure" aria-label="Permalink to ‚Äú2.1 Readability &amp; Structure‚Äù">‚Äã</a></h3><ul><li>Class names clearly indicate the <strong>hierarchy and relationships</strong>.</li></ul><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.card__header--highlighted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... }</span></span></code></pre></div><h3 id="_2-2-avoids-css-conflicts" tabindex="-1">2.2 Avoids CSS Conflicts <a class="header-anchor" href="#_2-2-avoids-css-conflicts" aria-label="Permalink to ‚Äú2.2 Avoids CSS Conflicts‚Äù">‚Äã</a></h3><ul><li>Unique names reduce <strong>collisions in global CSS</strong>.</li></ul><h3 id="_2-3-reusability-modularity" tabindex="-1">2.3 Reusability &amp; Modularity <a class="header-anchor" href="#_2-3-reusability-modularity" aria-label="Permalink to ‚Äú2.3 Reusability &amp; Modularity‚Äù">‚Äã</a></h3><ul><li>Blocks are <strong>independent and self-contained</strong>, making components easier to <strong>reuse</strong>.</li></ul><h3 id="_2-4-predictable-scalable" tabindex="-1">2.4 Predictable &amp; Scalable <a class="header-anchor" href="#_2-4-predictable-scalable" aria-label="Permalink to ‚Äú2.4 Predictable &amp; Scalable‚Äù">‚Äã</a></h3><ul><li>Large projects benefit from <strong>consistent naming</strong> across teams.</li><li>Makes <strong>maintenance easier</strong>, even with multiple developers.</li></ul><h3 id="_2-5-framework-agnostic" tabindex="-1">2.5 Framework Agnostic <a class="header-anchor" href="#_2-5-framework-agnostic" aria-label="Permalink to ‚Äú2.5 Framework Agnostic‚Äù">‚Äã</a></h3><ul><li>Works with <strong>plain HTML, React, Vue, Angular</strong>, or server-rendered apps.</li></ul><hr><h2 id="_3Ô∏è‚É£-modern-considerations" tabindex="-1">3Ô∏è‚É£ Modern Considerations <a class="header-anchor" href="#_3Ô∏è‚É£-modern-considerations" aria-label="Permalink to ‚Äú3Ô∏è‚É£ Modern Considerations‚Äù">‚Äã</a></h2><ul><li><strong>With CSS Modules:</strong> BEM is less needed because class names are automatically <strong>scoped locally</strong>.</li></ul><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styles </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./Button.module.css&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{styles.button}&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li><p><strong>With Tailwind CSS:</strong> Utility classes replace semantic naming; BEM can become redundant.</p></li><li><p><strong>With CSS-in-JS:</strong> Components encapsulate styles; naming conventions are often unnecessary.</p></li></ul><hr><h2 id="_4Ô∏è‚É£-example" tabindex="-1">4Ô∏è‚É£ Example <a class="header-anchor" href="#_4Ô∏è‚É£-example" aria-label="Permalink to ‚Äú4Ô∏è‚É£ Example‚Äù">‚Äã</a></h2><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* BEM */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.card</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.card__title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.card__title--highlighted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... }</span></span></code></pre></div><ul><li>Clear separation of <strong>block, element, modifier</strong>.</li><li>Anyone reading the code immediately knows <strong>where styles apply</strong>.</li></ul><hr><h3 id="‚úÖ-summary" tabindex="-1">‚úÖ Summary <a class="header-anchor" href="#‚úÖ-summary" aria-label="Permalink to ‚Äú‚úÖ Summary‚Äù">‚Äã</a></h3><ul><li><p><strong>BEM is still valid</strong>, especially in large projects or team environments.</p></li><li><p>Provides <strong>consistency, modularity, and maintainability</strong>.</p></li><li><p>In modern frameworks:</p><ul><li><strong>CSS Modules / CSS-in-JS / Tailwind</strong> reduce the necessity of BEM.</li><li>BEM is most valuable when <strong>working with global CSS or multi-developer teams</strong>.</li></ul></li></ul><blockquote><p>üí° Senior Tip: Even if using modern tools, understanding BEM is valuable‚Äîit teaches <strong>modular thinking and naming discipline</strong>, which improves maintainable code.</p></blockquote>`,35)])])}const k=s(l,[["render",t]]);export{g as __pageData,k as default};
